<blocks app="Snap! 7, https://snap.berkeley.edu" version="2"><palette><category name="RIAC" color="216,45,45,1"/><category name="eBrain" color="33,33,33,1"/><category name="Advanced eBrain" color="0,116,143,1"/></palette><block-definition s="connect to IP %&apos;ip&apos;" type="command" category="other"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><block s="reportJoinWords"><list><l>if (eb == undefined ) {eb = new EveBrain(&apos;ws://</l><block var="ip"/><l>:8899/websocket&apos;);&#xD;console.log(eb.connected);&#xD;} else {&#xD;if (eb.connected == false) {&#xD;eb.url= "ws://</l><block var="ip"/><l>:8899/websocket";  eb.connect();}}</l></list></block></block><list></list></block><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>ebUSB = undefined; // signal not connected by usb</l></block><list></list></block></script></block-definition><block-definition s="connect USB" type="command" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>eb = undefined; // signal that not connected by wifi&#xD;USBconnect().then(function() {&#xD;  world.moveon = 1;&#xD;}).catch(function(s) {&#xD;  morphicAlert("USB Connection Failed!", &#xD;  "Connection to robot by USB failed.", &#xD;  "Make sure to select a port when the window shows up.");&#xD;  world.moveon = -1;&#xD;});&#xD;&#xD;ebUSB = new EveBrainUSB();</l></block><list></list></block></script></block-definition><block-definition s="connected" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>&#xD;try {&#xD;  if ((eb != undefined ? eb.connected : false) || (ebUSB != undefined ? ebUSB.connected : false)){&#xD;    return true; &#xD;  } else {&#xD;    return false;&#xD;  }&#xD;} catch(e) {&#xD;  return false;&#xD;}</l></block><list></list></block></block></script></block-definition><block-definition s="test connection" type="command" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>try {&#xD;  if ((eb != undefined) || (ebUSB != undefined)){&#xD;    //it thinks its connected over websock, let&apos;s test the connection&#xD;   if (eb != undefined) {&#xD;     eb.connected = false;&#xD;     eb.version(function(status,msg){eb.connected = true;});&#xD;   } else {&#xD;     //it thinks we are connected over USB&#xD;     ebUSB.testConnection();&#xD;   } &#xD;  }&#xD;} catch(e) {&#xD;  console.log(e);&#xD;}</l></block><list></list></block></script></block-definition><block-definition s="Connect to eBrain %&apos;ip&apos;" type="command" category="RIAC"><header></header><code></code><translations></translations><inputs><input type="%s">USB<options>USB&#xD;WIFI =192.168.4.1</options></input></inputs><script><block s="doIf"><block s="reportNot"><custom-block s="world modified"></custom-block></block><script><custom-block s="addJS %s"><custom-block s="eBrainJS"></custom-block></custom-block><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>world.modified = 1;</l></block><list></list></block></script></block><custom-block s="test connection"></custom-block><block s="doWait"><l>0.1</l></block><block s="doIf"><block s="reportNot"><custom-block s="connected"></custom-block></block><script><block s="doIfElse"><block s="reportEquals"><block var="ip"/><l>USB</l></block><script><block s="doIfElse"><custom-block s="can use webserial"></custom-block><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>world.port = &apos;&apos;;&#xD;world.moveon = 0;</l></block><list></list></block><custom-block s="connect USB"></custom-block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block><block s="doIf"><block s="reportEquals"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block><l>-1</l></block><script><block s="doStopThis"><l><option>this block</option></l></block></script></block></script><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>morphicAlert("ERROR!", "ERROR! This device on this browser cannot use a USB connection!",&#xD;"Special note: if you are on snap.robotinacan.com and you wish to connect using USB please change http to https in the titlebar");</l></block><list></list></block><block s="doStopThis"><l><option>this block</option></l></block></script></block></script><script><block s="doIfElse"><custom-block s="can use unsecure websocket"></custom-block><script><block s="doIfElse"><block var="ip"/><script><custom-block s="connect to IP %s"><block var="ip"/></custom-block></script><script><custom-block s="connect"></custom-block></script></block></script><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>morphicAlert("ERROR!", "ERROR! This device on this browser cannot use a WiFi connection!",&#xD;"Special note: if you are on snap.robotinacan.com and you wish to connect using WiFi please change https to http in the titlebar");</l></block><list></list></block><block s="doStopThis"><l><option>this block</option></l></block></script></block></script></block></script></block><custom-block s="test connection"></custom-block><block s="doWait"><l>0.3</l></block><block s="doIf"><block s="reportNot"><custom-block s="connected"></custom-block></block><script><custom-block s="test connection"></custom-block><block s="doWait"><l>0.3</l></block><block s="doIf"><block s="reportNot"><custom-block s="connected"></custom-block></block><script><block s="doIfElse"><block s="reportAnd"><custom-block s="can use unsecure websocket"></custom-block><block s="reportNot"><custom-block s="can use webserial"></custom-block></block></block><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>morphicAlert("Connection Failure!", &#xD;"Connection Failure!",&#xD;"Ensure you are connected to the eBrain over WiFi, this device cannot use the USB port.",&#xD;"Special note: if you are on snap.robotinacan.com and want to connect over USB, go to the https version.", "See Help for more details");</l></block><list></list></block></script><script><block s="doIfElse"><block s="reportAnd"><custom-block s="can use webserial"></custom-block><block s="reportNot"><custom-block s="can use unsecure websocket"></custom-block></block></block><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>morphicAlert("Connection Failure!", "Connection Failure! Please ensure you have connected to the right USB port.",&#xD;"Ensure you are connected to the eBrain over USB, this version of Snap can only connect over USB.",&#xD;"Special note: if you are on snap.robotinacan.com and you wish to connect using WiFi please change https to http in the titlebar.");</l></block><list></list></block></script><script><block s="doIfElse"><block s="reportAnd"><custom-block s="can use webserial"></custom-block><custom-block s="can use unsecure websocket"></custom-block></block><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>morphicAlert("Connection Failure!", "Connection failed!",&#xD;"In this mode you may connect via USB or over WiFi",&#xD;"Please type the IP address to use WiFi or type USB to use the USB port");</l></block><list></list></block></script><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>morphicAlert("Connection Failure!", "Connection Failure!",&#xD;"Snap was unable to detect any method of connecting to the eBrain. Try reloading or closing and opening snap.");</l></block><list></list></block></script></block></script></block></script></block></script><comment w="90" collapsed="false">Signal to user connection failure</comment></block></script></block></script></block-definition><block-definition s="eBrainJS" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><l>var escapable = /[\x00-\x1f\ud800-\udfff\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufff0-\uffff]/g;&#xD;var attempts = 0;&#xD;var eb;&#xD;var ebUSB;&#xD;&#xD;function filterUnicode(quoted){&#xD;&#xD;  escapable.lastIndex = 0;&#xD;  if( !escapable.test(quoted)) return quoted;&#xD;&#xD;  return quoted.replace( escapable, function(a){&#xD;    return &apos;&apos;;&#xD;  });&#xD;}&#xD;&#xD;/**&#xD; * ParentEveBrain has the movement functions (move, turn,&#xD; * forward, etc) and digitalInput. These functions then &#xD; * call the send function, which subclasses need to define.&#xD; * Methods required to implement: send_msg.&#xD; * &#xD; * NOTE: the API for callbacks here is: state (usually started &#xD; * or complete), message (the returned message from the robot), optional.&#xD; * Optional is not passed usually, so it is undefined (except when stop() is used).&#xD; */&#xD;var ParentEveBrain = function() {&#xD;  this.digitalSensor = [];&#xD;  this.robot_state = &apos;idle&apos;;&#xD;  this.cbs = {};&#xD;  this.msg_stack = [];&#xD;  this.analogSensor = {level: null};&#xD;  this.distanceSensor = {level: null};&#xD;  this.tempSensor = {level: null};&#xD;  this.humidSensor = {level: null};&#xD;  this.config = null;&#xD;  this.sensorState = {};&#xD;}&#xD;&#xD;ParentEveBrain.prototype = {&#xD;  constructor: ParentEveBrain,&#xD;&#xD;  /**&#xD;   * Deals with the callback, and queues up the message to be sent to ebrain.&#xD;   * If the command is not &apos;important&apos; (ie not &apos;stop&apos;, etc) it is queued up.&#xD;   * The subclasses must call process_msg_queue when the robot is idle to&#xD;   * make sure queued messages are indeed sent, and must shift() the queue once &#xD;   * a response is received.&#xD;   * @param msg Message to send&#xD;   * @param cb callback for message&#xD;   */&#xD;  send: function(msg, cb){&#xD;    msg = filterUnicode(msg);&#xD;    msg.id = Math.random().toString(36).substring(2, 12);&#xD;    if(cb){&#xD;      this.cbs[msg.id] = cb;&#xD;    }&#xD;    if(msg.arg &amp;&amp; msg.arg.toString() != &apos;[object Object]&apos;) {&#xD;      msg.arg = msg.arg.toString();&#xD;    }&#xD;    if([&apos;stop&apos;, &apos;pause&apos;, &apos;resume&apos;, &apos;ping&apos;, &apos;version&apos;].indexOf(msg.cmd) &gt;= 0){&#xD;      this.send_msg(msg);&#xD;    }else{&#xD;      this.msg_stack.push(msg);&#xD;      this.process_msg_queue();&#xD;    }&#xD;  },&#xD;&#xD;  process_msg_queue: function(){&#xD;    if(this.robot_state === &apos;idle&apos; &amp;&amp; this.msg_stack.length &gt; 0){&#xD;      this.robot_state = &apos;receiving&apos;;&#xD;      this.send_msg(this.msg_stack[0]);&#xD;    }&#xD;  },&#xD;&#xD;  clearMessagesCallbacks: function() {&#xD;    this.cbs = {};&#xD;    this.msg_stack = [];&#xD;  },&#xD;&#xD;  stop: function(){&#xD;    var self = this;&#xD;    this.send({cmd:&apos;stop&apos;}, function(state, msg, recursion){&#xD;      if(state === &apos;complete&apos; &amp;&amp; !recursion){&#xD;        for(var i in self.cbs){&#xD;          // console.log(&apos;calling callback &apos; + self.cbs[i]);&#xD;          self.cbs[i](&apos;complete&apos;, undefined, true);&#xD;        }&#xD;        self.robot_state = &apos;idle&apos;;&#xD;        self.clearMessagesCallbacks();&#xD;      }&#xD;    });&#xD;  },&#xD;  /**&#xD;   * Initiates wifi scan.&#xD;   * @param {function} callback Called when info on the WiFi networks is received.&#xD;   */&#xD;  wifiScan: function(callback) {&#xD;    var self = this;&#xD;    this.send({cmd: "startWifiScan"}, null); // don&apos;t need a callback when the scan has started&#xD;    this.cbs[&apos;wifiScan&apos;] = function(state, message) {&#xD;      callback(state, message); // chain given callback&#xD;    }&#xD;  },&#xD;&#xD;  connect_to_network: function(SSID, PASS, callback) {&#xD;    this.send({cmd: &apos;setConfig&apos;, arg: {sta_ssid: SSID, sta_pass: PASS}}, callback);&#xD;  },&#xD;&#xD;  postToServer: function (onOff, server_host, sec, temp, dist, callback) {&#xD;    onOff = onOff === &apos;On&apos; ? 1 : 0;&#xD;    this.send({&#xD;      cmd: "postToServer",&#xD;      arg: { "onOff": onOff, "server": server_host, "time": sec, "toggleTempHumidity":temp,"toggleDistance":dist }&#xD;    }, callback);&#xD;  },&#xD;&#xD;  digitalInput: function(pin_number, cb){&#xD;    var self = this;&#xD;    this.send({cmd: &apos;digitalInput&apos;, arg:pin_number}, function(state, msg){&#xD;      cb(state, msg);&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.digitalSensor[pin_number] = msg.msg;&#xD;      }&#xD;    });&#xD;  },&#xD;&#xD;  digitalNotify: function(pin_number, cb) {&#xD;    var self = this;&#xD;    this.send({cmd: &apos;digitalNotify&apos;, arg:pin_number}, cb);&#xD;  },&#xD;&#xD;  digitalStopNotify: function(pin_number, cb) {&#xD;    // Remove the pin status from sensorState&#xD;    var index = &apos;pin_&apos; + pin_number + &apos;_status&apos;;&#xD;    delete this.sensorState[index];&#xD;    this.send({cmd: &apos;digitalStopNotify&apos;, arg:pin_number}, cb);&#xD;  },&#xD;&#xD;  analogInput: function(pin_number, cb){&#xD;    var self = this;&#xD;    this.send({cmd: &apos;analogInput&apos;, arg:pin_number}, function(state, msg){&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.analogSensor.level = msg.msg;&#xD;        cb(state, msg);&#xD;      }&#xD;    });&#xD;  },&#xD;&#xD;  gpio: function(pin, pin_state, cb){&#xD;    this.send({cmd: pin_state[0], arg:pin}, cb);&#xD;  },&#xD;&#xD;  gpio_pwm: function(pin_select,pin_value, cb){&#xD;    this.send({cmd: pin_select, arg:pin_value}, cb);&#xD;  },&#xD;&#xD;  distanceInput: function(cb){&#xD;    var self = this;&#xD;    this.send({cmd: &apos;distanceSensor&apos;}, function(state, msg){&#xD;      cb(state, msg);&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.distanceSensor.level = msg.msg;&#xD;      }&#xD;    });&#xD;  },&#xD;&#xD;  temperature: function(cb){&#xD;    var self = this;&#xD;    this.send({cmd: &apos;temperature&apos;}, function(state, msg){&#xD;      cb(state, msg);&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.tempSensor.level = msg.msg;&#xD;      }&#xD;    });&#xD;  },&#xD;&#xD;  humidity: function(cb){&#xD;    var self = this;&#xD;    this.send({cmd: &apos;humidity&apos;}, function(state, msg){&#xD;      cb(state, msg);&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.humidSensor.level = msg.msg;&#xD;      }&#xD;    });&#xD;  },&#xD;&#xD;  beep: function(note,duration,cb){&#xD;    this.send({cmd: &apos;beep&apos; , arg: [note, duration*1000]}, cb);&#xD;  },&#xD;&#xD;  getConfig: function(callback) {&#xD;    var self = this;&#xD;    this.send({cmd: &apos;getConfig&apos;}, function(state, msg) {&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.config = msg.msg;&#xD;      }&#xD;      callback(state, msg);&#xD;    });&#xD;  },&#xD;&#xD;  setServo: function(servoNum, angle, callback) {&#xD;    if (servoNum == 1) { // This is delierately a loose comparison&#xD;      this.send({cmd: "servo", arg: angle}, callback);&#xD;    } else if (servoNum == 2) {&#xD;      this.send({cmd: "servoII", arg: angle}, callback);&#xD;    }&#xD;  },&#xD;&#xD;  move: function(direction, distance, cb){&#xD;    // If we pass this first check, distance is a number or a string parseable as such&#xD;    if (!(typeof distance === &apos;number&apos; || !isNaN(distance))) {&#xD;      throw new Error(&apos;The distance must be a number&apos;);&#xD;    } else if (+distance &lt; 0) {&#xD;      throw new Error(&apos;For this command, distance must be positive.&apos;);&#xD;    }&#xD;    this.send({cmd: direction, arg: distance}, cb);&#xD;  },&#xD;&#xD;  turn: function(direction, angle, cb){&#xD;    this.send({cmd: direction, arg: angle}, cb);&#xD;  },&#xD;&#xD;  forward: function(distance, cb){&#xD;    this.move(&apos;forward&apos;, distance, cb);&#xD;  },&#xD;&#xD;  back: function(distance, cb){&#xD;    this.move(&apos;back&apos;, distance, cb);&#xD;  },&#xD;&#xD;  left: function(distance, cb){&#xD;    this.move(&apos;right&apos;, distance, cb);&#xD;  },&#xD;&#xD;  right: function(distance, cb){&#xD;    this.move(&apos;left&apos;, distance, cb);&#xD;  },&#xD;&#xD;  leftMotorForward: function(distance, cb){&#xD;    this.move(&apos;leftMotorF&apos;, distance, cb);&#xD;  },&#xD;&#xD;  rightMotorForward: function(distance, cb){&#xD;    this.move(&apos;rightMotorF&apos;, distance, cb);&#xD;  },&#xD;&#xD;  &#xD;  leftMotorBackward: function(distance, cb){&#xD;    this.move(&apos;leftMotorB&apos;, distance, cb);&#xD;  },&#xD;&#xD;  rightMotorBackward: function(distance, cb){&#xD;    this.move(&apos;rightMotorB&apos;, distance, cb);&#xD;  },&#xD;&#xD;  arc: function(angle,radius,repeat,cb){&#xD;    this.send({cmd: &apos;arc&apos; , arg:[angle,radius,repeat]}, cb);&#xD;  }&#xD;}&#xD;&#xD;&#xD;var EveBrain = function(url){&#xD;  ParentEveBrain.call(this);&#xD;  this.url = url;&#xD;  this.connect();&#xD;  this.cbs = {};&#xD;  this.listeners = [];&#xD;  this.wifiNetworks = {};&#xD;}&#xD;&#xD;EveBrain.prototype = {&#xD;&#xD;  connected: false,&#xD;  error: false,&#xD;  timeoutTimer: undefined,&#xD;&#xD;  connect: function(){&#xD;    if(!this.connected &amp;&amp; !this.error){&#xD;      var self = this;&#xD;      try { &#xD;        //clear any previous websockets and clear msg queue and all timers&#xD;        clearTimeout(self.timeoutTimer);&#xD;        clearTimeout(self.connTimeout);&#xD;        clearTimeout(self.reconnectTimer);&#xD;        self.ws.close();&#xD;        self.robot_state = &apos;idle&apos;;&#xD;        self.msg_stack = [];&#xD;        self.cbs = {};&#xD;      }&#xD;      catch(error) {&#xD;        console.log(error);&#xD;      }&#xD;      this.has_connected = false;&#xD;      this.ws = filterUnicode(new WebSocket(this.url));&#xD;      this.ws.onmessage = function(ws_msg){self.handle_ws(ws_msg)};&#xD;      this.ws.onopen = function(){&#xD;        self.version(function(){&#xD;          self.setConnectedState(true);&#xD;          attempts = 0;&#xD;        });&#xD;      }&#xD;      this.ws.onerror = function(err){self.handleError(err); attempts += 1;}&#xD;      this.ws.onclose = function(err){self.handleError(err); attempts += 1;}&#xD;      if (attempts &lt; 10) {&#xD;        this.connTimeout = window.setTimeout(function(){&#xD;          if(!self.connected){&#xD;            try { &#xD;              self.ws.close();;&#xD;            }&#xD;            catch(error) {&#xD;              console.log(error);&#xD;            }&#xD;          } &#xD;        }, 1000);&#xD;      }&#xD;    }&#xD;  },&#xD;&#xD;  refresh: function(){&#xD;    var self = this;&#xD;    self.ws.close();&#xD;    clearTimeout(self.connTimeout);&#xD;    self.robot_state = &apos;idle&apos;;&#xD;    self.msg_stack = [];&#xD;    self.cbs = {};&#xD;    this.has_connected = false;&#xD;    this.ws = filterUnicode(new WebSocket(this.url));&#xD;    this.ws.onmessage = function(ws_msg){self.handle_ws(ws_msg)};&#xD;    this.ws.onopen = function(){&#xD;      self.version(function(){&#xD;        self.setConnectedState(true);&#xD;      });&#xD;    }&#xD;    this.ws.onerror = function(err){self.handleError(err)}&#xD;    this.ws.onclose = function(err){self.handleError(err)}&#xD;  },&#xD;&#xD;  setConnectedState: function(state){&#xD;    var self = this;&#xD;    clearTimeout(self.connTimeout);&#xD;    self.connected = state;&#xD;    if(state){ self.has_connected = true; }&#xD;    if(self.has_connected){&#xD;      setTimeout(function(){&#xD;        self.broadcast(self.connected ? &apos;connected&apos; : &apos;disconnected&apos;);&#xD;      }, 100);&#xD;    }&#xD;    // Try to auto reconnect if disconnected&#xD;    if(state){&#xD;      if(self.reconnectTimer){&#xD;        clearTimeout(self.reconnectTimer);&#xD;        self.reconnectTimer = undefined;&#xD;      }&#xD;    }else{&#xD;      if(!self.reconnectTimer &amp;&amp; attempts &lt; 10){&#xD;          self.reconnectTimer = setTimeout(function(){&#xD;          self.reconnectTimer = undefined;&#xD;          self.connect();&#xD;        }, 1000);&#xD;        // If at the end of the attempts, show the user an alert and pause their code.&#xD;      } else if (attempts &gt;= 10) {&#xD;        morphicAlert("Robot Disconnected!",&#xD;          "Robot disconnected by WiFi!\nPlease reconnect using the Connect block and unpause.");&#xD;        world.moveon = 1;&#xD;        world.children[0].stage.threads.pauseAll();&#xD;      }&#xD;    }&#xD;  },&#xD;&#xD;  broadcast: function(msg){&#xD;    for(i in this.listeners){&#xD;      if(this.listeners.hasOwnProperty(i)){&#xD;        this.listeners[i](msg);&#xD;      }&#xD;    }&#xD;  },&#xD;&#xD;  addListener: function(listener){&#xD;    this.listeners.push(listener);&#xD;  },&#xD;&#xD;  handleError: function(err){&#xD;    if(err instanceof CloseEvent || err === &apos;Timeout&apos;){&#xD;      if(this.ws.readyState === WebSocket.OPEN){&#xD;        this.ws.close()&#xD;      }&#xD;      this.setConnectedState(false);&#xD;      clearTimeout(self.reconnectTimer);&#xD;      self.reconnectTimer = undefined;&#xD;      this.msg_stack = [];&#xD;    }else{&#xD;      console.log(err);&#xD;    }&#xD;  },&#xD;&#xD;  // note: many functions are in the ParentEveBrain.&#xD;&#xD;  //EveOneCommands&#xD;&#xD;  analogInputPCF: function(pin_number, cb){&#xD;    var self = this;&#xD;    this.send({cmd: &apos;readSensors&apos;, arg:pin_number}, function(state, msg){&#xD;      if(state === &apos;complete&apos; &amp;&amp; undefined != msg){&#xD;        self.analogSensor.level = msg.msg;&#xD;        cb(self.analogSensor.level);&#xD;      }&#xD;    });&#xD;  },&#xD;&#xD;  /*pause: function(cb){&#xD;    this.send({cmd:&apos;pause&apos;}, cb);&#xD;  },&#xD;&#xD;  resume: function(cb){&#xD;    this.send({cmd:&apos;resume&apos;}, cb);&#xD;  },*/&#xD;&#xD;  ping: function(cb){&#xD;    this.send({cmd:&apos;ping&apos;}, cb);&#xD;  },&#xD;&#xD;  version: function(cb){&#xD;    this.send({cmd:&apos;version&apos;}, cb);&#xD;  },&#xD;&#xD;  send_msg: function(msg){&#xD;    var self = this;&#xD;    msg = filterUnicode(msg);&#xD;    console.log(msg);&#xD;    if(this.ws.readyState === WebSocket.OPEN){&#xD;      this.ws.send(JSON.stringify(msg));&#xD;    }&#xD;    this.timeoutTimer = window.setTimeout(function(){ self.handleError("Timeout") }, 3000);&#xD;  },&#xD;&#xD;  handle_ws: function(ws_msg){&#xD;    if (typeof ws_msg != &apos;undefined&apos;) {&#xD;      msg = JSON.parse(ws_msg.data);&#xD;      msg.msg = filterUnicode(msg.msg);&#xD;      msg.id = filterUnicode(msg.id);&#xD;      msg.status = filterUnicode(msg.status);&#xD;      console.log(msg);&#xD;      clearTimeout(this.timeoutTimer);&#xD;      if(msg.status === &apos;notify&apos;){&#xD;        this.broadcast(msg.id);&#xD;        this.sensorState[msg.id] = msg.msg;&#xD;        if (this.cbs[msg.id]) {&#xD;          this.cbs[msg.id](&apos;notify&apos;, msg);&#xD;          delete this.cbs[msg.id];&#xD;        }&#xD;        return;&#xD;      }&#xD;      if(this.msg_stack.length &gt; 0 &amp;&amp; this.msg_stack[0].id == msg.id){&#xD;        if(msg.status === &apos;accepted&apos;){&#xD;          if(this.cbs[msg.id]){&#xD;            this.cbs[msg.id](&apos;started&apos;, msg);&#xD;          }&#xD;          this.robot_state = &apos;running&apos;;&#xD;        }else if(msg.status === &apos;complete&apos;){&#xD;          if(this.cbs[msg.id]){&#xD;            this.cbs[msg.id](&apos;complete&apos;, msg);&#xD;            delete this.cbs[msg.id];&#xD;          }&#xD;          this.msg_stack.shift();&#xD;          if(this.msg_stack.length === 0){&#xD;            this.broadcast(&apos;program_complete&apos;);&#xD;          }&#xD;          this.robot_state = &apos;idle&apos;;&#xD;          this.process_msg_queue();&#xD;        }&#xD;      }else{&#xD;        if(this.cbs[msg.id]){&#xD;          this.cbs[msg.id](&apos;complete&apos;, msg);&#xD;          delete this.cbs[msg.id];&#xD;        }&#xD;      }&#xD;      &#xD;      if (msg.status === &apos;error&apos;) {&#xD;        morphicAlert("Error", msg[&apos;msg&apos;]); // Alert user about error&#xD;      }&#xD;      if(msg.status &amp;&amp; msg.status === &apos;error&apos; &amp;&amp; msg.msg === &apos;Too many connections&apos;){&#xD;        this.error = true;&#xD;        this.broadcast(&apos;error&apos;);&#xD;      }&#xD;    } else {&#xD;      ws_msg.data = 0;&#xD;      ws_msg.status = 0;&#xD;      ws_msg.id = 0;&#xD;    }&#xD;  },&#xD;&#xD;  robot_state: &apos;idle&apos;,&#xD;  msg_stack: []&#xD;}&#xD;&#xD;// Add the movement functions to the EveBrain prototype&#xD;for (parentMemberName in ParentEveBrain.prototype) {&#xD;  EveBrain.prototype[parentMemberName] = ParentEveBrain.prototype[parentMemberName];&#xD;}&#xD;&#xD;&#xD;var EveBrainUSB = function() {&#xD;  ParentEveBrain.call(this);&#xD;  this.cbs = {};&#xD;  // Initially, set connected to true if there is a port.&#xD;  if (world.port) {&#xD;    this.connected = true;&#xD;  } else {&#xD;    this.connected = false;&#xD;  }&#xD;};&#xD;&#xD;EveBrainUSB.prototype = Object.create(ParentEveBrain.prototype);&#xD;Object.defineProperty(EveBrainUSB.prototype, &apos;constructor&apos;, {&#xD;  value: EveBrainUSB,&#xD;  enumerable: false,&#xD;  writable: true&#xD;});&#xD;&#xD;EveBrainUSB.prototype.send_msg = function(message, callback) {&#xD;  message = filterUnicode(message);&#xD;  writeToStream(JSON.stringify(message));&#xD;}&#xD;&#xD;/**&#xD; * Runs the callback associated with the given message and manages&#xD; * the robot&apos;s state.&#xD; * @param message Message from ebrain&#xD; */&#xD;EveBrainUSB.prototype.doCallback = function(message) {&#xD;  if(message &amp;&amp; message.status == &apos;accepted&apos;) {&#xD;    this.robot_state = &apos;running&apos;;&#xD;    if(this.cbs[message.id]){&#xD;      this.cbs[message.id](&apos;started&apos;, message);&#xD;    }&#xD;  } else if(message &amp;&amp; message.status == &apos;complete&apos;){&#xD;    if(this.cbs[message.id]){&#xD;      this.cbs[message.id](&apos;complete&apos;, message);&#xD;      delete this.cbs[message.id];&#xD;    }&#xD;    this.robot_state = &apos;idle&apos;;&#xD;    this.msg_stack.shift(); // Pop message that prompted this response off queue&#xD;    this.process_msg_queue();&#xD;  } else if(message &amp;&amp; message.status === &apos;notify&apos;){&#xD;    this.sensorState[message.id] = message.msg;&#xD;    if (this.cbs[message.id]) {&#xD;      this.cbs[message.id](&apos;notify&apos;, message);&#xD;      delete this.cbs[message.id];&#xD;    }&#xD;    return;&#xD;  } else if (message &amp;&amp; message.status === &apos;error&apos;) {&#xD;    morphicAlert("Error", message.msg);&#xD;    // this.msg_stack.shift(); // Pop message that prompted this response off queue&#xD;  }&#xD;}&#xD;&#xD;/**&#xD; * Tests the connection. If the robot is connected, will&#xD; * (async) set this.connected = true (once the robot responds).&#xD; * Sets this.connected = false at the start.&#xD; */&#xD;EveBrainUSB.prototype.testConnection = function() {&#xD;  this.connected = false;&#xD;  var self = this;&#xD;  this.send({cmd: "version"}, function(status, msg) {&#xD;    if (status === &apos;complete&apos;) {&#xD;      self.connected = true;&#xD;    }&#xD;  });&#xD;}&#xD;&#xD;let inputDone;&#xD;let outputDone;&#xD;world.outputStream = undefined; // Set this to undefined so it is easy to check for its existence&#xD;&#xD;async function USBconnect() {&#xD;  // Request &amp; open port here.&#xD;  world.port = await navigator.serial.requestPort();&#xD;  if (ebUSB) {&#xD;    ebUSB.connected = true;&#xD;  }&#xD;  // Wait for the port to open.&#xD;  await world.port.open({ baudRate: 230400 });&#xD;&#xD;  // on disconnect, alert user and pause Snap!&#xD;  world.port.addEventListener(&apos;disconnect&apos;, event =&gt; {&#xD;    if (ebUSB) {&#xD;      ebUSB.connected = false; // signal disconnection to other code.&#xD;    }&#xD;    morphicAlert("Robot Disconnected!", &#xD;    "Robot disconnected by USB!\nPlease reconnect using the Connect block and unpause.");&#xD;    world.moveon = 1;&#xD;    world.children[0].stage.threads.pauseAll();&#xD;  });&#xD;&#xD;  // Setup the output stream&#xD;  const encoder = new TextEncoderStream();&#xD;  outputDone = encoder.readable.pipeTo(world.port.writable);&#xD;  world.outputStream = encoder.writable;&#xD;&#xD;  // Make stream&#xD;  let decoder = new TextDecoderStream();&#xD;  inputDone = world.port.readable.pipeTo(decoder.writable);&#xD;  inputStream = decoder.readable;&#xD;&#xD;  world.reader = inputStream.getReader();&#xD;  readLoop(); // Start infinite read loop&#xD;}&#xD;&#xD;/**&#xD; * This reads from the serial in a loop, and &#xD; * runs the given callbacks (using ebUSB).&#xD; */&#xD;async function readLoop() {&#xD;  world.USB = &apos;&apos;;&#xD;  console.log("USB Reader Listening...");&#xD;&#xD;  while (true) {&#xD;    const { value, done } = await world.reader.read();&#xD;    if (value) {&#xD;      world.USB += value;&#xD;      console.log (value + &apos;\n&apos;);&#xD;&#xD;      // Now, I check if the JSON is complete and respond to the callback if necessary&#xD;      // and remove the message from the stack&#xD;      if (world.USB.includes(&apos;}&apos;)) {&#xD;        var messages = tryParseeBrainResponse(world.USB);&#xD;        for (var i = 0; i &lt; messages.parsed.length; i++ ) {&#xD;          var message = messages.parsed[i];&#xD;          if (ebUSB) {&#xD;            ebUSB.doCallback(message);&#xD;          }&#xD;        }&#xD;        world.USB = &apos;&apos;;&#xD;        if (messages.unparseable) {&#xD;          world.USB = messages.unparseable;&#xD;        }&#xD;      }&#xD;    }&#xD;    if (done) {&#xD;      console.log(&apos;[readLoop] DONE&apos;, done);&#xD;      world.reader.releaseLock();&#xD;      break;&#xD;    }&#xD;  }&#xD;}&#xD;&#xD;/**&#xD; * Tries to parse string as json. Also verifies that it is valid (check it has an id).&#xD; * NOTE: the json MUST end with &apos;\r\n&apos;&#xD; * @return An object of form {parsed, unparseable}, where parseable is a &#xD; * list of all parseable objects and, unparseable is a string representing what remaining&#xD; * bits couldn&apos;t be parsed (if such exists).&#xD;*/&#xD;function tryParseeBrainResponse(jsonString) {&#xD;  var out = {parsed: []};&#xD;&#xD;  // First, try and split if there are multiple objects being returned&#xD;  var jsons = jsonString.split(&apos;\r\n&apos;);&#xD;  for (var i = 0; i &lt; jsons.length; i++) {&#xD;    try {&#xD;      var response = JSON.parse(jsons[i]);&#xD;      if (response &amp;&amp; typeof response === "object" &amp;&amp; response.id) {&#xD;        out.parsed.push(response);&#xD;      }&#xD;    } catch (e) {&#xD;      // Only add a str to unparseable if it&apos;s at the end.&#xD;      if (i == jsons.length - 1) {&#xD;        out.unparseable = jsons[i];&#xD;      }&#xD;    }&#xD;  }&#xD;  return out;&#xD;}&#xD;&#xD;function writeToStream(...lines) {&#xD;  // Write to output stream&#xD;  const writer = world.outputStream.getWriter();&#xD;  lines.forEach((line) =&gt; {&#xD;    console.log(&apos;[SEND]&apos;, line);&#xD;    writer.write(line + &apos;\n&apos;);&#xD;  });&#xD;  writer.releaseLock();&#xD;}&#xD;&#xD;// https://forum.snap.berkeley.edu/t/how-do-i-make-a-dialog-box-with-custom-buttons/6347/4&#xD;/**&#xD; * Creates a morhpic dialog and shows it to the user, with one &apos;Close&apos; button.&#xD; * If there is another alert with the same title and message, this one will not be shown.&#xD; * NOTE: this uses non bold text, otherwise the text is clipped.&#xD; * @param {string} title Title for the dialog&#xD; * @param {String} message Rest parameters of lines to show in the body of the dialog.&#xD; * If it does not contain Strings, calls toString on it.&#xD; */&#xD;function morphicAlert(title, ...messages) {&#xD;  if (Array.isArray(messages) &amp;&amp; messages.length &gt; 0) {&#xD;    var message = "";&#xD;    for (var i = 0; i &lt; messages.length - 1; i++) {&#xD;      message += messages[i] + "\n";&#xD;    }&#xD;    message += messages[messages.length - 1];&#xD;    morphicAlertString(title, message);&#xD;  } else if (typeof messages === "string") {&#xD;    morphicAlertString(title, messages);&#xD;  } else if (messages === null || messages === undefined) {&#xD;    morphicAlertString(title, "[Error message is missing. Please report that this happened to the developers.]");&#xD;  } else {&#xD;    morphicAlertString(title, messages.toString());&#xD;  }&#xD;}&#xD;&#xD;var activeAlerts = new Map();&#xD;&#xD;/**&#xD; * Creates a morhpic dialog and shows it to the user, with one &apos;Close&apos; button.&#xD; * NOTE: use morphicAlert instead, it has more robust type checking.&#xD; * @param {string} title Title for the dialog&#xD; * @param {string} message Message in the body of the dialog&#xD; */&#xD; function morphicAlertString(title, message) {&#xD;  var alertContents = title + message;&#xD;  if (activeAlerts.get(alertContents) !== undefined) {&#xD;    // don&apos;t create a dialog if an identical one exists.&#xD;    return;&#xD;  }&#xD;&#xD;  let box = new DialogBoxMorph(); // make dialog&#xD;  // add label (in the weirdest way imaginable)&#xD;  box.labelString = title;&#xD;  box.createLabel();&#xD;  const addLabel = function (text, type) {&#xD;    let txt = new TextMorph(text);&#xD;    // Text should be bold to match the snap style but has to be &#xD;    // false here, otherwise the text overflows.&#xD;    txt.isBold = false;&#xD;    box[&apos;add&apos; + type](txt);&#xD;  }&#xD;  addLabel(message, &apos;Body&apos;) // do not change the second input of these&#xD;  box.titleBarColor = new Color(255, 0, 0, 1); // Make titlebar red&#xD;  box.titlePadding = 12; // make titlebar taller&#xD;&#xD;  // Add this box to the activeAlerts map, and make the close button work.&#xD;  activeAlerts.set(alertContents, box);&#xD;  box.cancelAndProcess = function() {&#xD;    box.ok();&#xD;    activeAlerts.delete(alertContents);&#xD;  }&#xD;  // This button will close the dialog and remove it from the list of active alerts&#xD;  box.addButton(&apos;cancelAndProcess&apos;, &apos;Close&apos;);&#xD;  box.fixLayout(); // required, otherwise box looks weird&#xD;  box.popUp(world); // popup box&#xD;}</l></block></script></block-definition><block-definition s="addJS %&apos;JS_FILE&apos;" type="command" category="other"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>JS_FILE</l></list><l>var po = document.createElement(&apos;script&apos;);&#xD;  po.type = &apos;text/javascript&apos;;&#xD;  po.async = true;&#xD;  po.innerHTML = JS_FILE;&#xD;  var s = document.getElementsByTagName(&apos;script&apos;)[0];&#xD;  s.parentNode.insertBefore(po, s)</l></block><list><block var="JS_FILE"/></list></block></script></block-definition><block-definition s="world modified" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.modified == 1 || world.modified != undefined;</l></block><list></list></block></block></script></block-definition><block-definition s="Forward %&apos;mm&apos;" type="command" category="RIAC"><header></header><code></code><translations></translations><inputs><input type="%s">100</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>mm</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.forward(mm,function(state, msg){&#xD;  if(state == &apos;complete&apos;){&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="mm"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Back %&apos;mm&apos;" type="command" category="RIAC"><header></header><code></code><translations></translations><inputs><input type="%s">100</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>mm</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.back(mm,function(state,msg){&#xD;  if(state == &apos;complete&apos;){&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="mm"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Left %&apos;mm&apos;" type="command" category="RIAC"><header></header><code></code><translations></translations><inputs><input type="%s">90</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>mm</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.left(mm,function(state,msg){&#xD;  if(state == &apos;complete&apos;){&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="mm"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Right %&apos;mm&apos;" type="command" category="RIAC"><header></header><code></code><translations></translations><inputs><input type="%s">90</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>mm</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.right(mm,function(state,msg){&#xD;  if(state == &apos;complete&apos;){&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="mm"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="connect" type="command" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>ebUSB = undefined; // signal not connected by usb&#xD;if (eb == undefined) {&#xD;  eb = new EveBrain(&apos;ws://192.168.4.1:8899/websocket&apos;);&#xD;  console.log(eb.connected);&#xD;} else {&#xD;  if (eb.connected == false) {&#xD;    eb.url = "ws://192.168.4.1:8899/websocket";&#xD;    eb.connect();&#xD;  }&#xD;}</l></block><list></list></block></script></block-definition><block-definition s="connection type" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>try {&#xD;  if(eb != undefined ? eb.connected : false){&#xD;    return &apos;WEB&apos;; &#xD;  }  &#xD; else if(ebUSB != undefined ? ebUSB.connected: false){&#xD;    return &apos;USB&apos;; &#xD;  }&#xD; else {&#xD;   return &apos;NONE&apos;; &#xD;  }&#xD;} catch(e) {&#xD;  return "NONE";&#xD;}</l></block><list></list></block></block></script></block-definition><block-definition s="Stop" type="command" category="RIAC"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>eb.stop();</l></block><list><custom-block s="connection object"></custom-block></list></block></script></block-definition><block-definition s="GPIO Write Pin: %&apos;Pin&apos; %&apos;ON/OFF&apos;" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s" readonly="true">4<options>4&#xD;5&#xD;10&#xD;16&#xD;14&#xD;12&#xD;13&#xD;0&#xD;2</options></input><input type="%s" readonly="true">gpio_on<options>gpio_on&#xD;gpio_off</options></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>Pin</l><l>State</l><l>eb</l></list><l>world.moveon = 0;&#xD;try{&#xD;  eb.gpio(Pin,[State],function(state, msg){&#xD;    if (state == &apos;complete&apos;) {&#xD;      world.moveon = 1;&#xD;    }&#xD;  });&#xD;}&#xD;catch(e){&#xD;}</l></block><list><block var="Pin"/><block var="ON/OFF"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="GPIO Read Pin %&apos;Pin&apos;" type="reporter" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s" readonly="true">4<options>4&#xD;5&#xD;10&#xD;16&#xD;14&#xD;12&#xD;13&#xD;0&#xD;2</options></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>Pin</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.digitalInput(Pin,function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="Pin"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>Pin</l><l>eb</l></list><l>return eb.digitalSensor[Pin];</l></block><list><block var="Pin"/><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Analog Read" type="reporter" category="eBrain"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.analogInput(0,function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return eb.analogSensor.level;</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Read Distance" type="reporter" category="eBrain"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.distanceInput(function(state, msg) { &#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return  eb.distanceSensor.level;</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Temperature Read" type="reporter" category="eBrain"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.temperature(function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return eb.tempSensor.level;</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Humidity Read" type="reporter" category="eBrain"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.humidity(function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return eb.humidSensor.level;</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="PWM Pin: %&apos;Pin&apos; Value (0-255): %&apos;pin_value&apos;" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s" readonly="true">5<options>5&#xD;10&#xD;16</options></input><input type="%n">255</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>pin</l><l>pin_value</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.gpio_pwm("gpio_pwm_" + pin, pin_value, function(state, msg){&#xD;  if (state == &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="Pin"/><block var="pin_value"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Beep Pin 5 Duration: %&apos;duration&apos; Note: %&apos;note&apos;" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%n">1</input><input type="%n">60</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>duration</l><l>note</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.beep(note,duration,function(state, msg){&#xD;  if (state == &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="duration"/><block var="note"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Connect to Network SSID: %&apos;SSID&apos; Password: %&apos;PASS&apos;" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>SSID</l><l>PASS</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.connect_to_network(SSID, PASS, function(state, msg){&#xD;  if (state == &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="SSID"/><block var="PASS"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Get WiFi Networks" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.wifiScan(function(){&#xD;  world.moveon = 1;&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>&#xD;var networks = eb.sensorState["wifiScan"];&#xD;let txt = "";&#xD;for (let i = 0; i &lt; networks.length; i++){&#xD;&#xD;txt = txt.concat(networks[i][0]);&#xD;if(i != networks.length){  &#xD;  txt = txt.concat(",");}&#xD;}&#xD;return(networks);</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Set Servo %&apos;one&apos; Angle %&apos;angle&apos;" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s" readonly="true">1<options>1&#xD;2</options></input><input type="%n">90</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>angle</l><l>one</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.setServo(one, angle, function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="angle"/><block var="one"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Get IP" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.getConfig(function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return eb.config.sta_ip;</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Get Config" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.getConfig(function(state, message){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return  JSON.stringify(eb.config);</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="Get Robot Name" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>eb</l></list><l>world.moveon = 0;&#xD;eb.getConfig(function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l></list><l>return  eb.config.ap_ssid;</l></block><list><custom-block s="connection object"></custom-block></list></block></block></script></block-definition><block-definition s="%&apos;motor&apos; Motor %&apos;direction&apos; %&apos;mm&apos;" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s" readonly="true">Left<options>Left&#xD;Right</options></input><input type="%s" readonly="true">Forward<options>Forward&#xD;Back</options></input><input type="%n">100</input></inputs><script><block s="doIfElse"><block s="reportNot"><block s="reportListContainsItem"><block s="reportNewList"><list><l>Left</l><l>Right</l></list></block><block var="motor"/></block></block><script><block s="doRun"><block s="reportJSFunction"><list></list><l>alert(&apos;Must use with "Left" or "Right" motor &apos;);</l></block><list></list></block></script><script><block s="doIfElse"><block s="reportNot"><block s="reportListContainsItem"><block s="reportNewList"><list><l>Forward</l><l>Back</l></list></block><block var="direction"/></block></block><script><block s="doRun"><block s="reportJSFunction"><list></list><l>alert(&apos;Must use going "Forward" or "Backward"&apos;);</l></block><list></list></block></script><script><block s="doRun"><block s="reportJSFunction"><list><l>motor</l><l>direction</l><l>mm</l><l>eb</l></list><l>world.moveon = 0;&#xD;var actionStr = motor.toLowerCase() + &apos;Motor&apos; + (direction === &apos;Forward&apos; ? &apos;F&apos; : &apos;B&apos;);&#xD;eb.move(actionStr, mm, function(state, msg) {&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="motor"/><block var="direction"/><block var="mm"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script></block></script></block></script></block-definition><block-definition s="Close Connection" type="command" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doIf"><block s="reportEquals"><custom-block s="connection type"></custom-block><l>WEB</l></block><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>eb.ws.close();</l></block><list></list></block></script></block><block s="doIf"><block s="reportEquals"><custom-block s="connection type"></custom-block><l>USB</l></block><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>world.port.close()</l></block><list></list></block></script></block></script></block-definition><block-definition s="Set eBrain Posting %&apos;onOff&apos; to Server %&apos;server_host&apos; every %&apos;sec&apos; Seconds Post Distance Sensor: %&apos;dist&apos; TemperatureHumidity Sensor: %&apos;temp&apos;" type="command" category="Advanced eBrain"><header></header><code></code><translations></translations><inputs><input type="%s" readonly="true">On<options>On&#xD;Off</options></input><input type="%s">https://json.robotinacan.com/posts</input><input type="%n">10</input><input type="%b" readonly="true">false<options>0&#xD;1</options></input><input type="%b" readonly="true">false<options>0&#xD;1</options></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>onOff</l><l>server_host</l><l>sec</l><l>temp</l><l>dist</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.postToServer(onOff, server_host, sec, temp?1:0, dist?1:0, function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="onOff"/><block var="server_host"/><block var="sec"/><block var="temp"/><block var="dist"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="Move Left Motor %&apos;LeftMM&apos; mm and Right Motor %&apos;RightMM&apos; mm" type="command" category="eBrain"><header></header><code></code><translations></translations><inputs><input type="%s">100</input><input type="%s">200</input></inputs><script><block s="doIfElse"><block s="reportEquals"><block var="LeftMM"/><block var="RightMM"/></block><script><block s="doRun"><block s="reportJSFunction"><list><l>mm</l><l>eb</l></list><l>world.moveon = 0;&#xD;var callback = function(state, msg) {&#xD;    if (state === &apos;complete&apos;) {&#xD;        world.moveon = 1;&#xD;    }&#xD;};&#xD;if (mm &gt; 0) {&#xD;    eb.forward(mm, callback);&#xD;} else {&#xD;    eb.back(-mm, callback);&#xD;}</l></block><list><block var="LeftMM"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script><script><block s="doRun"><block s="reportJSFunction"><list><l>LeftMM</l><l>RightMM</l><l>eb</l></list><l>// Calculate the ratio between mm and degrees&#xD;var steps_per_mm = 2038.0 / 254.4;&#xD;var steps_per_degree = ((108.5 * 3.1416) / 360) * steps_per_mm;&#xD;var degrees_per_mm = steps_per_degree / steps_per_mm;&#xD;&#xD;// Find the absolute values of the distances&#xD;var absLeftMM = Math.abs(LeftMM);&#xD;var absRightMM = Math.abs(RightMM);&#xD;&#xD;world.moveon = 0;&#xD;var callback = function(state, msg) {&#xD;    if (state === &apos;complete&apos;) {&#xD;        world.moveon = 1;&#xD;    }&#xD;};&#xD;&#xD;// start of with moving both motors&#xD;var minDistance = Math.min(absLeftMM, absRightMM);&#xD;if (LeftMM &gt;= 0 &amp;&amp; RightMM &gt;= 0) {&#xD;    eb.forward(minDistance, callback);&#xD;} else if (LeftMM &lt;= 0 &amp;&amp; RightMM &lt;= 0) {&#xD;    eb.back(minDistance, callback);&#xD;} else if (LeftMM &gt; 0) {&#xD;    eb.right(minDistance * degrees_per_mm, callback);&#xD;} else {&#xD;    eb.left(minDistance * degrees_per_mm, callback);&#xD;}</l></block><list><block var="LeftMM"/><block var="RightMM"/><custom-block s="connection object"></custom-block></list><comment w="140.83333333333334" collapsed="false">Here, run the command to run the motors as long as the smaller distance (ie if we are moving the Left one 50mm and the Right one 80mm, move both 50mm first).</comment></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block><block s="doRun"><block s="reportJSFunction"><list><l>LeftMM</l><l>RightMM</l><l>eb</l></list><l>// Calculate the ratio between mm and degrees&#xD;var steps_per_mm = 2038.0 / 254.4;&#xD;var steps_per_degree = ((108.5 * 3.1416) / 360) * steps_per_mm;&#xD;var degrees_per_mm = steps_per_degree / steps_per_mm;&#xD;// Find the absolute values of the distances&#xD;var absLeftMM = Math.abs(LeftMM);&#xD;var absRightMM = Math.abs(RightMM);&#xD;&#xD;world.moveon = 0;&#xD;var callback = function(state, msg) {&#xD;    if (state === &apos;complete&apos;) {&#xD;        world.moveon = 1;&#xD;    }&#xD;};&#xD;&#xD;var minDistance = Math.min(absLeftMM, absRightMM);&#xD;&#xD;&#xD;//End with moving the remaining motor the remaining distance&#xD;if (absLeftMM &gt; absRightMM) {&#xD;    var remainingDistance = absLeftMM - minDistance;&#xD;    if (LeftMM &lt; 0) {&#xD;        eb.rightMotorBackward(remainingDistance, callback);&#xD;    } else {&#xD;        eb.rightMotorForward(remainingDistance, callback);&#xD;    }&#xD;} else {&#xD;    var remainingDistance = absRightMM - minDistance;&#xD;    if (RightMM &lt; 0) {&#xD;        eb.leftMotorForward(remainingDistance, callback);&#xD;    } else {&#xD;        eb.leftMotorBackward(remainingDistance, callback);&#xD;    }&#xD;}&#xD;&#xD;</l></block><list><block var="LeftMM"/><block var="RightMM"/><custom-block s="connection object"></custom-block></list><comment w="90" collapsed="false">Here, run the motor with the longer distance to move (ie if we are moving the Left one 50mm and the Right one 80mm, now we are moving the Right one 30mm).</comment></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return world.moveon;</l></block><list></list></block></block></script><comment w="90" collapsed="false">If both distances are the same, run a forward/backwards command</comment></block></script></block-definition><block-definition s="connection object" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doIfElse"><block s="reportEquals"><custom-block s="connection type"></custom-block><l>WEB</l></block><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return eb;</l></block><list></list></block></block></script><script><block s="doIfElse"><block s="reportEquals"><custom-block s="connection type"></custom-block><l>USB</l></block><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return ebUSB;</l></block><list></list></block></block></script><script><block s="doRun"><block s="reportJSFunction"><list><l></l></list><l>// Since this block might be called before Connect, and Connect loads in morphicAlert,&#xD;// this falls back to a js alert.&#xD;try {&#xD;  morphicAlert("Connection Error!", "You are not connected to your eBrain!");&#xD;} catch (e) {&#xD;  alert("You are not connected to your eBrain!");&#xD;}</l></block><list></list></block><block s="doStopThis"><l><option>all</option></l></block></script></block></script></block></script></block-definition><block-definition s="delete var %&apos;names&apos;" type="command" category="variables"><comment x="0" y="0" w="217" collapsed="false">This block deletes all the variables with the names given (inside input list).&#xD;&#xD;Each name will make only one variable deletion, and this will be the variable found following the scope order: &apos;script&apos; -&gt; &apos;sprite&apos; -&gt; &apos;global&apos;.&#xD;&#xD;If we have a &quot;testing&quot; sprite variable and also a &quot;testing&quot; global one, deleting &quot;testing&quot; will delete only the sprite one (Yes! we can also do &quot;delete var (testing, testing)&quot; to delete both.&#xD;&#xD;If one variable does not exists (in any scope) an error happens, stopping block action in that point. You can check it before with the &quot;does var (name) exists?&quot;block. </comment><header></header><code></code><translations>pt:remove as variveis _&#xD;ca:esborra les variables _&#xD;es:borrar variables _&#xD;de:lschen var _&#xD;</translations><inputs><input type="%mult%txt"></input></inputs><script><block s="doForEach"><l>each item</l><block var="names"/><script><block s="doRun"><block s="reportJSFunction"><list><l>varName</l><l>proc</l></list><l>if ((typeof varName) != "string" || varName === "") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;if (typeof proc.homeContext.variables.vars[varName] !== &apos;undefined&apos;) {&#xD;    delete proc.homeContext.variables.vars[varName];&#xD;} else if (this.deletableVariableNames().indexOf(varName) != -1) {&#xD;    this.deleteVariable(varName);&#xD;} else {&#xD;    throw new Error("variable doesn&apos;t exist: " + varName);&#xD;}</l></block><list><block var="each item"/></list></block></script></block><block s="doRun"><block s="reportJSFunction"><list></list><l>var ide = this.parentThatIsA(IDE_Morph);&#xD;ide.flushBlocksCache(&apos;variables&apos;); // b/c of inheritance&#xD;ide.refreshPalette();</l></block><list></list></block></script></block-definition><block-definition s="set var %&apos;name&apos; to %&apos;value&apos;" type="command" category="variables"><comment x="0" y="0" w="240.4931640625" collapsed="false">This block sets the given value (last input) to the variable named with the name givent (var input).&#xD;&#xD;It looks for that variable following the scope order &apos;script&apos; -&gt; &apos;sprite&apos; -&gt; &apos;global&apos; (the first match it finds).&#xD;&#xD;If that variable does not exist (in any scope) an error happens, stopping their script. You can check it before using the &quot;does var (name) exists?&quot; block. </comment><header></header><code></code><translations>ca:assigna a _ el valor _&#xD;es:asignar a _ el valor _&#xD;pt:altera _ para _&#xD;de:setze var _ auf _&#xD;</translations><inputs><input type="%s"><options>_getVarNamesDict</options></input><input type="%s"></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>varName</l><l>value</l><l>proc</l></list><l>if ((typeof varName) != "string") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;proc.homeContext.variables.setVar(varName, value);</l></block><list><block var="name"/><block var="value"/></list></block></script></block-definition><block-definition s="listify %&apos;jsonString&apos;" type="reporter" category="operators"><header></header><code></code><translations>pt:os dados JSON _ em formato de lista&#xD;</translations><inputs><input type="%mlt"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>jsonString</l></list><l>return listify(JSON.parse(jsonString));&#xD;&#xD;function listify(jsonObject) {&#xD;  if (jsonObject instanceof Array) {&#xD;    return new List(jsonObject.map(function(eachElement) { return listify(eachElement)}));&#xD;  } else if (jsonObject instanceof Object) {&#xD;    return new List(Object.keys(jsonObject).map(function(eachKey) { return new List([eachKey,listify(jsonObject[eachKey])])} ))&#xD;  } else {&#xD;    return jsonObject&#xD;  }&#xD;}</l></block><list><block var="jsonString"/></list></block></block></script></block-definition><block-definition s="value at key %&apos;key&apos; of %&apos;lst&apos;" type="reporter" category="operators"><header></header><code></code><translations>pt:o valor com chave _ em _&#xD;</translations><inputs><input type="%s"></input><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doForEach"><l>each item</l><block var="lst"/><script><block s="doIf"><block s="reportEquals"><block s="reportListItem"><l>1</l><block var="each item"/></block><block var="key"/></block><script><block s="doReport"><block s="reportListItem"><l>2</l><block var="each item"/></block></block></script></block></script></block></script></block><block s="doReport"><l></l></block></script></block-definition><block-definition s="key: %&apos;key&apos; value: %&apos;value&apos;" type="reporter" category="operators"><header></header><code></code><translations>pt:um par (chave: _ , valor: _ )&#xD;</translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><block s="reportNewList"><list><block var="key"/><block var="value"/></list></block></block></script></block-definition><block-definition s="var %&apos;name&apos;" type="reporter" category="variables"><comment x="0" y="0" w="178.00000000000003" collapsed="false">This block reports the value of the variable with the name given.&#xD;&#xD;It looks for that variable following the scope order &apos;script&apos; -&gt; &apos;sprite&apos; -&gt; &apos;global&apos; (the first match it finds).&#xD;&#xD;If that variable does not exist (in any scope) an error happens, stopping their script. You can check it before using the &quot;does var (name) exists?&quot; block. </comment><header></header><code></code><translations>pt:o valor de _&#xD;</translations><inputs><input type="%s"><options>_getVarNamesDict</options></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>varName</l><l>proc</l></list><l>if ((typeof varName) != "string") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;return proc.homeContext.variables.getVar(varName);</l></block><list><block var="name"/></list></block></block></script></block-definition><block-definition s="does var %&apos;name&apos; exist?" type="predicate" category="variables"><comment x="0" y="0" w="146" collapsed="false">This block reports &quot;true&quot; if there is a variable with this given name (input slot) in that context.&#xD;&#xD;It can be a global, sprite or script variable.&#xD;&#xD;Otherwise it reports &quot;false&quot;.</comment><header></header><code></code><translations>pt:a varivel _ existe&#xD;ca:existeix la variable _ ?&#xD;es:existe la variable _ ?&#xD;de:existiert var _ ?&#xD;</translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>varName</l><l>proc</l></list><l>if ((typeof varName) != "string" || varName === "") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;return proc.homeContext.variables.silentFind(varName)? true:false;</l></block><list><block var="name"/></list></block></block></script></block-definition><block-definition s="show var %&apos;name&apos;" type="command" category="variables"><comment x="0" y="0" w="181" collapsed="false">This block turns on (show) the watcher view on stage (if it was not already activated) of the variable with the given name (slot input).&#xD;&#xD;It can only access to the closest variable scope (if there different variables with the same name in different scopes) following the order &apos;script&apos; -&gt; &apos;sprite&apos; -&gt; &apos;global&apos;.&#xD;&#xD;No errors if that variable does not exist.</comment><header></header><code></code><translations>ca:mostra la variable _&#xD;es:mostrar variable _&#xD;pt:mostra a varivel _&#xD;de:zeige var _&#xD;</translations><inputs><input type="%s"><options>_getVarNamesDict</options></input></inputs><script><block s="doIf"><custom-block s="does var %s exist?"><block var="name"/></custom-block><script><block s="doRun"><block s="reportJSFunction"><list><l>varName</l><l>proc</l></list><l>    var varFrame = proc.homeContext.variables,&#xD;        stage,&#xD;        watcher,&#xD;        target,&#xD;        label,&#xD;        others,&#xD;        isGlobal,&#xD;        name = varName;&#xD;&#xD;    if (name instanceof Context) {&#xD;        if (name.expression.selector === &apos;reportGetVar&apos;) {&#xD;            name = name.expression.blockSpec;&#xD;        } else {&#xD;            proc.doChangePrimitiveVisibility(name.expression, false);&#xD;            return;&#xD;        }&#xD;    }&#xD;    if (proc.homeContext.receiver) {&#xD;        stage = proc.homeContext.receiver.parentThatIsA(StageMorph);&#xD;        if (stage) {&#xD;            target = varFrame.silentFind(name);&#xD;            if (!target) {return; }&#xD;            // first try to find an existing (hidden) watcher&#xD;            watcher = detect(&#xD;                stage.children,&#xD;                morph =&gt; morph instanceof WatcherMorph &amp;&amp;&#xD;                    morph.target === target &amp;&amp;&#xD;                        morph.getter === name&#xD;            );&#xD;            if (watcher !== null) {&#xD;                watcher.show();&#xD;                watcher.fixLayout(); // re-hide hidden parts&#xD;                return;&#xD;            }&#xD;            // if no watcher exists, create a new one&#xD;            isGlobal = contains(&#xD;                proc.homeContext.receiver.globalVariables().names(),&#xD;                varName&#xD;            );&#xD;            if (isGlobal || target.owner) {&#xD;                label = name;&#xD;            } else {&#xD;                label = name + &apos; &apos; + localize(&apos;(temporary)&apos;);&#xD;            }&#xD;            watcher = new WatcherMorph(&#xD;                label,&#xD;                SpriteMorph.prototype.blockColor.variables,&#xD;                target,&#xD;                name&#xD;            );&#xD;            watcher.setPosition(stage.position().add(10));&#xD;            others = stage.watchers(watcher.left());&#xD;            if (others.length &gt; 0) {&#xD;                watcher.setTop(others[others.length - 1].bottom());&#xD;            }&#xD;            stage.add(watcher);&#xD;            watcher.fixLayout();&#xD;        }&#xD;    }</l></block><list><block var="name"/></list></block></script></block></script></block-definition><block-definition s="hide var %&apos;name&apos;" type="command" category="variables"><comment x="0" y="0" w="181" collapsed="false">This block turns off (hide) the watcher view on stage (if it was not already activated) of the variable with the given name (slot input).&#xD;&#xD;It can only access to the closest variable scope (if there different variables with the same name in different scopes) following the order &apos;script&apos; -&gt; &apos;sprite&apos; -&gt; &apos;global&apos;.&#xD;&#xD;No errors if that variable does not exist.</comment><header></header><code></code><translations>ca:amaga la variable _&#xD;es:esconder variable _&#xD;pt:esconde a varivel _&#xD;de:verstecke var _&#xD;</translations><inputs><input type="%s"><options>_getVarNamesDict</options></input></inputs><script><block s="doIf"><custom-block s="does var %s exist?"><block var="name"/></custom-block><script><block s="doRun"><block s="reportJSFunction"><list><l>varName</l><l>proc</l></list><l>    // to delete all temporary watchers, use the primitive "hide" with no inputs&#xD;    var varFrame = proc.homeContext.variables,&#xD;        stage,&#xD;        watcher,&#xD;        target,&#xD;        name = varName;&#xD;&#xD;    if (name instanceof Context) {&#xD;        if (name.expression.selector === &apos;reportGetVar&apos;) {&#xD;            name = name.expression.blockSpec;&#xD;        } else {&#xD;            proc.doChangePrimitiveVisibility(name.expression, true);&#xD;            return;&#xD;        }&#xD;    }&#xD;    if (!name) {&#xD;        proc.doRemoveTemporaries();&#xD;        return;&#xD;    }&#xD;    if (proc.homeContext.receiver) {&#xD;        stage = proc.homeContext.receiver.parentThatIsA(StageMorph);&#xD;        if (stage) {&#xD;            target = varFrame.find(name);&#xD;            watcher = detect(&#xD;                stage.children,&#xD;                morph =&gt; morph instanceof WatcherMorph &amp;&amp;&#xD;                    morph.target === target &amp;&amp;&#xD;                        morph.getter === name&#xD;            );&#xD;            if (watcher !== null) {&#xD;                if (watcher.isTemporary()) {&#xD;                    watcher.destroy();&#xD;                } else {&#xD;                    watcher.hide();&#xD;                }&#xD;            }&#xD;        }&#xD;    }&#xD;</l></block><list><block var="name"/></list></block></script></block></script></block-definition><block-definition s="create %&apos;scope&apos; var %&apos;names&apos;" type="command" category="variables"><comment x="0" y="0" w="146" collapsed="false">This block creates  new variables on the selected scope: global (for all sprites), sprite (for this sprite only) or script (only for that blocks stack) with the names given (in &apos;names&apos; list).&#xD;&#xD;If there is already a variable with that name in that scope, it does nothing: no errors and no overwrites.</comment><header></header><code></code><translations>pt:cria as variveis _ _&#xD;ca:crea les _ variables _&#xD;es:crear las _ variables _&#xD;de:erstellen _ var _&#xD;</translations><inputs><input type="%s" readonly="true">global<options>global&#xD;sprite&#xD;script</options></input><input type="%mult%txt"></input></inputs><script><block s="doIfElse"><block s="reportEquals"><block var="scope"/><l>script</l></block><script><block s="doForEach"><l>each item</l><block var="names"/><script><block s="doRun"><block s="reportJSFunction"><list><l>varName</l><l>proc</l></list><l>if ((typeof varName) != "string" || varName === "") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;if (!proc.homeContext.variables.vars[varName]) proc.homeContext.variables.addVar(varName);</l></block><list><block var="each item"/></list></block></script></block></script><script><block s="doDeclareVariables"><list><l>global</l></list></block><block s="doIfElse"><block s="reportEquals"><block var="scope"/><l>sprite</l></block><script><block s="doSetVar"><l>global</l><block s="reportBoolean"><l><bool>false</bool></l></block></block></script><script><block s="doSetVar"><l>global</l><block s="reportBoolean"><l><bool>true</bool></l></block></block></script></block><block s="doForEach"><l>each item</l><block var="names"/><script><block s="doRun"><block s="reportJSFunction"><list><l>varName</l><l>global</l><l>proc</l></list><l>if ((typeof varName) != "string" || varName === "") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;if (global &amp;&amp; !proc.homeContext.variables.parentFrame.parentFrame.vars[varName]) this.addVariable(varName, true);&#xD;if (!global &amp;&amp; !proc.homeContext.variables.parentFrame.vars[varName]) this.addVariable(varName, false);</l></block><list><block var="each item"/><block var="global"/></list></block></script></block><block s="doRun"><block s="reportJSFunction"><list></list><l>var ide = this.parentThatIsA(IDE_Morph);&#xD;ide.flushBlocksCache(&apos;variables&apos;); // b/c of inheritance&#xD;ide.refreshPalette();</l></block><list></list></block></script></block></script></block-definition><block-definition s="fetch %&apos;url&apos; %&apos;data&apos;" type="reporter" category="sensing"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><custom-block s="create %s var %mult%txt"><l>sprite</l><list><l>response</l></list></custom-block><block s="doRun"><block s="reportJSFunction"><list><l>url</l><l>proc</l></list><l>//Fetches data as a promise , on compleation saves to varable as text.&#xD;//if ((typeof varName) != "string") {&#xD;if ((typeof "response") != "string") {&#xD;    throw new Error("name isn&apos;t a string: " + varName);&#xD;}&#xD;&#xD;fetch(url)&#xD;  .then(response =&gt; response.json())&#xD;  .then(data =&gt; proc.homeContext.variables.setVar("response", JSON.stringify(data)));&#xD;&#xD;console.log(proc.homeContext.variables.allNames())</l></block><list><block var="url"/></list></block><block s="doWait"><l>0.2</l></block><block s="doReport"><block var="response"/></block></script></block-definition><block-definition s="%&apos;method&apos; url: %&apos;url&apos; send: %&apos;payload&apos; headers: %&apos;headers&apos;" type="reporter" category="sensing"><header></header><code></code><translations>pt:a resposta a _ de _ enviando _ e cabealhos _&#xD;</translations><inputs><input type="%s" readonly="true">GET<options>GET&#xD;POST&#xD;PUT&#xD;DELETE</options></input><input type="%s">https://snap.berkeley.edu</input><input type="%s"></input><input type="%mult%l" readonly="true"></input></inputs><script><custom-block s="create %s var %mult%txt"><l>sprite</l><list><l>response</l></list></custom-block><block s="doRun"><block s="reportJSFunction"><list><l>chosen_method</l><l>url</l><l>payload</l><l>headers</l><l>proc</l></list><l>console.log(chosen_method)&#xD;&#xD;payload = JSON.parse(payload)&#xD;&#xD;if (chosen_method == "GET") {&#xD;    fetch(url, {&#xD;            method: chosen_method&#xD;        })&#xD;        .then(response =&gt; response.json())&#xD;        .then(data =&gt; proc.homeContext.variables.setVar("response", JSON.stringify(data)))&#xD;} else if (chosen_method == "POST") {&#xD;    fetch(url, {&#xD;            method: chosen_method,&#xD;            headers: {&#xD;                &apos;Content-Type&apos;: &apos;application/json&apos;,&#xD;            },&#xD;            body: JSON.stringify(payload)&#xD;        })&#xD;        .then(response =&gt; response.json())&#xD;        .then(data =&gt; proc.homeContext.variables.setVar("response", JSON.stringify(data)))&#xD;}</l></block><list><block var="method"/><block var="url"/><block var="payload"/><block var="headers"/></list></block><block s="doWait"><l>0.5</l></block><block s="doReport"><block var="response"/></block></script></block-definition><block-definition s="Get Robot Status Server: %&apos;server&apos; Robot: %&apos;robot&apos;" type="reporter" category="Advanced eBrain"><comment x="0" y="0" w="90" collapsed="false">#### - change to your robot&apos;s alphanumeric name</comment><header></header><code></code><translations></translations><inputs><input type="%s">https://json.robotinacan.com/posts</input><input type="%s">RobotInACan-####</input></inputs><script><block s="doReport"><custom-block s="fetch %s %s"><block s="reportJoinWords"><list><block var="server"/><l>?_sort=id&amp;_order=desc&amp;_limit=1&amp;bot=</l><block var="robot"/></list></block><l></l></custom-block></block></script></block-definition><block-definition s="Post to Server: %&apos;server&apos; Robot: %&apos;robot&apos; Command: %&apos;cmd&apos; Argument: %&apos;arg&apos;" type="command" category="Advanced eBrain"><header></header><code></code><translations></translations><inputs><input type="%s">https://json.robotinacan.com/posts</input><input type="%s">RobotInACan-####</input><input type="%s">gpio_on<options>gpio_on&#xD;gpio_off&#xD;servo&#xD;servoII&#xD;forward&#xD;back&#xD;left&#xD;right&#xD;gpio_pwm_5&#xD;gpio_pwm_10&#xD;gpio_pwm_16</options></input><input type="%s">14</input></inputs><script><block s="doReport"><block s="evaluate"><block s="reifyReporter"><autolambda><custom-block s="%s url: %s send: %s headers: %mult%l"><l>POST</l><block var="server"/><block s="reportJoinWords"><list><l>{"cmd":"</l><block var="cmd"/><l>",  "arg":"</l><block var="arg"/><l>","bot":"</l><block var="robot"/><l>"}</l></list></block><list><l/></list></custom-block></autolambda><list></list></block><list></list></block></block></script></block-definition><block-definition s="Get Robot %&apos;Status&apos; Server: %&apos;server&apos; Robot: %&apos;robot&apos;" type="reporter" category="Advanced eBrain"><comment x="0" y="0" w="90" collapsed="false">#### - change to your robot&apos;s alphanumeric name</comment><header></header><code></code><translations></translations><inputs><input type="%mlt" readonly="true">analog<options>analog&#xD;digital_pins&#xD;refresh_rate&#xD;distance&#xD;temperature&#xD;humidity&#xD;bot&#xD;id</options></input><input type="%s">https://json.robotinacan.com/posts</input><input type="%s">RobotInACan-####</input></inputs><script><block s="doDeclareVariables"><list><l>response</l></list></block><block s="doSetVar"><l>response</l><custom-block s="fetch %s %s"><block s="reportJoinWords"><list><block var="server"/><l>?_sort=id&amp;_order=desc&amp;_limit=1&amp;bot=</l><block var="robot"/></list></block><l></l></custom-block></block><block s="doIfElse"><block s="reportEquals"><block s="reportLetter"><l>1</l><block var="response"/></block><l>[</l></block><script><block s="doReport"><custom-block s="value at key %s of %l"><block var="Status"/><block s="reportListItem"><l>1</l><custom-block s="listify %mlt"><block var="response"/></custom-block></block></custom-block></block></script><script><block s="doReport"><l></l></block></script></block></script></block-definition><block-definition s="can use unsecure websocket" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>try {&#xD;    websock = new WebSocket(&apos;ws://example.com&apos;);&#xD;} catch (e) {&#xD;    return false;&#xD;}&#xD;return true;</l></block><list></list></block></block></script></block-definition><block-definition s="can use webserial" type="reporter" category="other"><header></header><code></code><translations></translations><inputs></inputs><script><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l></l></list><l>return navigator.serial !== undefined;</l></block><list></list></block></block></script></block-definition><block-definition s="subscribe to notifications on pin %&apos;pin&apos;" type="command" category="Advanced eBrain"><header></header><code></code><translations></translations><inputs><input type="%n"><options>4&#xD;14&#xD;12&#xD;13&#xD;0&#xD;2</options></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>pin</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.digitalNotify(pin,function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="pin"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="unsubscribe from notifications on pin %&apos;pin&apos;" type="command" category="Advanced eBrain"><header></header><code></code><translations></translations><inputs><input type="%n"><options>4&#xD;14&#xD;12&#xD;13&#xD;0&#xD;2</options></input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>pin</l><l>eb</l></list><l>world.moveon = 0;&#xD;eb.digitalStopNotify(pin,function(state, msg){&#xD;  if (state === &apos;complete&apos;) {&#xD;    world.moveon = 1;&#xD;  }&#xD;});</l></block><list><block var="pin"/><custom-block s="connection object"></custom-block></list></block><block s="doWaitUntil"><block s="evaluate"><block s="reportJSFunction"><list></list><l>return world.moveon;</l></block><list></list></block></block></script></block-definition><block-definition s="subscription read from pin %&apos;pin&apos;" type="reporter" category="Advanced eBrain"><header></header><code></code><translations></translations><inputs><input type="%s"><options>4&#xD;14&#xD;12&#xD;13&#xD;0&#xD;2</options></input></inputs><script><block s="doIf"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l><l>pin</l></list><l>var index = &apos;pin_&apos; + pin + &apos;_status&apos;;&#xD;var pinValue = eb.sensorState[index];&#xD;return pinValue === null || pinValue === undefined;</l></block><list><custom-block s="connection object"></custom-block><block var="pin"/></list></block><script><block s="doRun"><block s="reportJSFunction"><list><l>pin</l></list><l>morphicAlert("Error", "Not subscribed to pin " + pin + "!");</l></block><list><block var="pin"/></list></block></script></block><block s="doReport"><block s="evaluate"><block s="reportJSFunction"><list><l>eb</l><l>pin</l></list><l>var index = &apos;pin_&apos; + pin + &apos;_status&apos;;&#xD;var pinValue = eb.sensorState[index];&#xD;return pinValue;</l></block><list><custom-block s="connection object"></custom-block><block var="pin"/></list></block></block></script></block-definition></blocks>

